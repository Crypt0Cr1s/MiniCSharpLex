 
   
/* ---------------Seccion de declaraciones preliminares--------------------*/
package minicsharplex;

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
import java.io.FileReader;
import java.util.ArrayList;

/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:
    
	 /* Reporte de error encontrado. */
    int errorCounter=0;
    public void syntax_error(Symbol s){
      errorCounter++;

        report_error("Error de Sintaxis recuperable No" + errorCounter + ".Linea: " + (s.left+1) + "Columna: " + (s.right+1) + ". Texto: \""+ s.value + "\"", null);
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void unrecovered_Syntax_error(Symbol s)throws java.lang.Exception {
        report_error("Error de sintaxis no recuperable No" + errorCounter + ".Linea: " + (s.left+1) + "Columna: " + (s.right+1) + ". Texto: \""+ s.value + "\"",null);
    }

    public void sem_error(String lexeme, String message) {
      errorCounter++;
      System.err.println("Semantic error");
      System.err.println("  "+ errorCounter + "==> " + message + ": "+ lexeme + "\n");
  }

    
    
    
    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */

   
   
   
:};   

   
/* ------------Declaracion de simbolos terminales y no terminales---------- */
   
/* Terminales (tokens obtenidos por el analizador lexico).  

   Terminales que no tienen un valor son listados primero, los terminales que
   tienen un valor como los enteros son listados en la segunda o demas lineas. */
terminal Object INCLUDE,ARCHIVO,PLUS, MINUS,CONSTANTE, MULTI, DIV, MOD, MINOR, MINOREQ ,MAJOR, MAJOREQ, ASIGNATION, EQUAL, NOTEQUAL, AND, OR, ADMIRATION, SEMICOLON, COMMA, POINT, CORCHIZQ, CORCHDER, PARENIZQ, PARENDER, LLAVEIZQ, LLAVEDER, CORCHDOBLE, VOID, INT, DOUBLE, BOOL, STRING, CLASS, INTERFACE, NULL, THIS, EXTENDS, IMPLEMENTS, FOR, WHILE, IF, ELSE, RETURN, BREAK, NEW, NEWARRAY, PRINT, READINT, READLINE, MALLOC, HEX, ENTERO, BOOLEAN, CADENA, DOBLE, IDENTIFIER, GETBYTE, SETBYTE;

   
/* No terminales usados en la seccion gramatical. 

   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a que
   no tienen tipo, pudiendo ser entero o String. */
non terminal Object     Start,Include, FormalsCont, Program, Decl, VariableDecl, Variable, Type, Expr1,FunctionDecl, FuncCont, Formals, ClassDecl, Ext, Imp, ClassField, ImpID, Field, InterfaceDecl, InterfaceProt,  Prototype, ProtCont, StmtBlock, StmtCont,StmtEnd, Stmt, IfStmt, StmtExpr, ElseIfStmt, WhileStmt, ForStmt, ReturnStmt, BreakStmt, PrintStmt, ExprPrint,  Expr, LValue, Call, CallCont, LibCall, Actuals,  Constant;

   

/* -------------Seccion de predencia y asociacion de los terminales----------- */
precedence left PLUS, MINUS;
precedence left MULTI, DIV,  MOD;
precedence left MINOR, MINOREQ, MAJOR, MAJOREQ, ASIGNATION, EQUAL, NOTEQUAL, AND, OR, ADMIRATION;
precedence left ELSE;
precedence left IDENTIFIER;

/* ------------------- Seccion de la gramatica ------------------------ */
   

Program ::= Program Decl
| /* ε */ ;

Decl ::= VariableDecl
| FunctionDecl
| ClassDecl
| InterfaceDecl
| error SEMICOLON
| error LLAVEDER ;

VariableDecl ::=  Variable SEMICOLON 
| CONSTANTE Variable SEMICOLON ;

Variable ::=   Type:t IDENTIFIER:n {: RESULT = ""; RESULT=RESULT.toString().concat("["+n+","+t+"]");if (!Tsimbols.put(n,"v",t))  System.out.println("  La variable " + n + " ya se encuentra declarada en el ambito actual"); :} ;

Type ::= INT {: RESULT = "int"; :}
| DOUBLE {: RESULT = "double"; :}
| BOOL {: RESULT = "bool"; :}
| STRING {: RESULT = "string"; :}
| IDENTIFIER:h {: RESULT = h.toString(); :}
| VOID
| Type CORCHDOBLE ;

FunctionDecl ::= FuncCont:n;

FuncCont ::= Type:t IDENTIFIER:n {: if(!Tsimbols.put(n.toString(),"m",t)) {System.out.println("Este metodo ya existe");} else {System.out.print(" Entradas de Metodo: "+n); Tsimbols.push();}:} PARENIZQ Formals:p {:Tsimbols.parametros(n.toString(),p);:} PARENDER StmtBlock:v {:Tsimbols.mreturn(t.toString(),v);System.out.print(" Salida de Bloque"); Tsimbols.pop();System.out.print(" Saliendo de Metodo " +n); Tsimbols.pop();:} ;

Formals ::= FormalsCont:a Variable:b {: if(a==null){a="";a = a.toString().concat(b.toString());}else{a = a.toString().concat(b.toString());} RESULT = a; :}
| /* ε */ ;

FormalsCont ::= FormalsCont:a Variable:b COMMA {:if(a==null){a="";}; a = a.toString().concat(b+"-"); RESULT = a;:}
| /* ε */ ;

ClassDecl ::= CLASS IDENTIFIER:h Ext:z  
{:
    if(z == null)
    {
        if(Tsimbols.putClass(h.toString(),null,null) != 0)
        {
            System.out.println("  La clase " + h + " ya se encuentra declarada en el ambito actual");
        }
    }
    else
    {
        switch(Tsimbols.putClass(h.toString(),z.toString(),null))
        {
            case 1:
            System.out.println("  La clase " + h + " ya se encuentra declarada en el ambito actual");
            break;

            case 2:
            System.out.println("  La clase " + z + " no existe en el ambito actual");
            break;                
        } 
    }
:} 
Imp LLAVEIZQ ClassField LLAVEDER
{:
      System.out.print("  Saliendo de la clase: "+h);
      Tsimbols.pop();
 :} ;

Ext ::= EXTENDS IDENTIFIER:n1 {: RESULT = n1; :}
| /* ε */ ;

Imp ::= IMPLEMENTS ImpID:e
| /* ε */ ;

ImpID ::= ImpID COMMA IDENTIFIER
| IDENTIFIER:a
{:

    if(a == null)
    {
        
    }
    else
    {   
        boolean K = Tsimbols.getInterfaces(a.toString());

        if(K == false)
        {
            System.out.println("  La interfaz " + a + " no se encuentra en el ambito actual");
        }
    }
 :} ;

ClassField ::= ClassField Field
| /* ε */ ;

Field ::= VariableDecl
| FunctionDecl ;

InterfaceDecl ::= INTERFACE IDENTIFIER:n1 {: if(Tsimbols.putClass(n1.toString(),null,null) != 0) System.out.println("  La interfaz " + n1 + " ya se encuentra declarada en el ambito actual"); :} LLAVEIZQ InterfaceProt LLAVEDER ;

InterfaceProt ::= InterfaceProt Prototype
| /* ε */ ;

Prototype ::= Type ProtCont
| VOID ProtCont;

ProtCont ::= IDENTIFIER PARENIZQ Formals PARENDER SEMICOLON ;

StmtBlock ::= LLAVEIZQ {:System.out.print(" Entrada de Bloque"); Tsimbols.push(); :} StmtCont:p {:RESULT=p;:} LLAVEDER ;

StmtCont ::= StmtEnd:p StmtCont:q{:if(p!=null){if(q==null){q="";q = q.toString().concat(p.toString());}else {q = q.toString().concat(p.toString());}}; RESULT = q; :}
| /* ε */ ;

StmtEnd ::= VariableDecl
| Stmt:p {:RESULT = p;:} ;

Stmt ::= StmtExpr:m{:RESULT=m;:} SEMICOLON
| IfStmt
| WhileStmt
| ForStmt
| BreakStmt
| ReturnStmt:p {:RESULT = p;:}
| PrintStmt
| StmtBlock ;

StmtExpr ::= Expr:n {:RESULT=n;:}
| /* ε */ ;

IfStmt ::= IF PARENIZQ Expr PARENDER Stmt ElseIfStmt ;

ElseIfStmt ::= ELSE Stmt
| /* ε */ ;

WhileStmt ::= WHILE PARENIZQ Expr PARENDER Stmt ;

ForStmt ::= FOR PARENIZQ StmtExpr SEMICOLON Expr SEMICOLON StmtExpr PARENDER Stmt ;

ReturnStmt ::= RETURN StmtExpr:p {:RESULT = p;:} SEMICOLON ;

BreakStmt ::= BREAK SEMICOLON ;

PrintStmt ::= PRINT PARENIZQ ExprPrint PARENDER SEMICOLON ;

ExprPrint ::= ExprPrint:a COMMA Expr:b {:a = a.toString().concat(","+b.toString()); RESULT = a;:}
| Expr:n {:RESULT=n.toString();:} ;

Expr ::= LValue:v ASIGNATION Expr:e 
{: 
    Tsimbols.Validar(v.toString(), e.toString());
:} 
| Constant:e {: RESULT = e; :}
| LValue:e {: RESULT = e; :}
| THIS
| Call 
| PARENIZQ Expr:p PARENDER {:RESULT = p;:}
| Expr1:e1 PLUS Expr:e2 {: RESULT = e1 + "+" + e2; :}
| Expr1:e1 MINUS Expr:e2 {: RESULT = e1 + "-" + e2; :}
| Expr1:e1 MULTI Expr:e2 {: RESULT = e1 + "*" + e2; :}
| Expr1:e1 DIV Expr:e2 {: RESULT = e1 + "/" + e2; :}
| Expr MOD Expr
| MINUS Expr
| Expr MINOR Expr
| Expr MINOREQ Expr
| Expr MAJOR Expr
| Expr MAJOREQ Expr
| Expr EQUAL Expr
| Expr NOTEQUAL Expr
| Expr AND Expr
| Expr OR Expr
| ADMIRATION Expr
| NEW PARENIZQ IDENTIFIER PARENDER
| NEWARRAY PARENIZQ Expr COMMA Type PARENDER
| READINT PARENIZQ PARENDER
| READLINE PARENIZQ PARENDER
| MALLOC PARENIZQ Expr PARENDER ;

Expr1 ::= Constant:e {: RESULT = e; :}
| IDENTIFIER:e {: RESULT = e; :} ;

LValue ::= IDENTIFIER:e {: RESULT = e; :}
| Expr POINT IDENTIFIER
| Expr CORCHIZQ Expr CORCHDER ;

Call ::= IDENTIFIER:n {:if(!Tsimbols.get_name(n.toString(), "m")){ System.out.println("***PELIGRO*** ==> El Método: " + n + " no ha sido declarado");}:} PARENIZQ Actuals:n1 {:Tsimbols.tipos(n.toString(),n1.toString());:} PARENDER
| Expr POINT IDENTIFIER CallCont
| Expr POINT LibCall CallCont ;

CallCont ::= PARENIZQ Actuals PARENDER ;

LibCall ::= GETBYTE PARENIZQ Expr PARENDER 
| SETBYTE PARENIZQ Expr COMMA Expr PARENDER ;

Actuals ::= ExprPrint:n {:System.out.println(n); RESULT=n;:}
| /* ε */ ;

Constant ::= ENTERO:e {: RESULT = e + "&int"; :}
| DOBLE:e {: RESULT = e + "&dob"; :}
| BOOLEAN:e {: RESULT = e + "&bool"; :}
| CADENA:e {: RESULT = e + "&str"; :}
| NULL {:RESULT = "&null"; :} ;